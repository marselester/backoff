package backoff

import (
	"math"
	"math/rand"
	"time"
)

// NewDecorrJitter returns a new DecorrJitter.
func NewDecorrJitter(options ...Option) *DecorrJitter {
	r := DecorrJitter{
		conf: Config{
			random:            rand.New(rand.NewSource(time.Now().UnixNano())),
			maxRetries:        MaxRetries,
			maxWaitSeconds:    MaxWait.Seconds(),
			multiplierSeconds: Multiplier.Seconds(),
		},
	}
	for _, opt := range options {
		opt(&r.conf)
	}

	return &r
}

// DecorrJitter is the exponential "decorrelated jitter" backoff from Polly project
// based on https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/.
// See https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry#new-jitter-recommendation and
// https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry/blob/master/src/Polly.Contrib.WaitAndRetry/Backoff.DecorrelatedJitterV2.cs.
type DecorrJitter struct {
	conf Config

	n     float64
	prev  float64
	delay float64
}

const (
	// pFactor is a factor used within the formula to help smooth the first calculated delay.
	pFactor = 4.0
	// rpScalingFactor is a factor used to scale the median values of the retry times
	// generated by the formula to be near whole seconds, to aid user comprehension.
	// This factor allows the median values to fall approximately at 1, 2, 4, ... seconds,
	// instead of 1.4, 2.8, 5.6, 11.2.
	rpScalingFactor = 1 / 1.4
)

// Next returns true if an attempt should be made.
func (r *DecorrJitter) Next() bool {
	switch {
	case r.n > r.conf.maxRetries:
		return false
	case r.n == r.conf.maxRetries:
		r.n++
		r.delay = 0
		return true
	}

	t := r.n + r.conf.random.Float64()
	next := math.Pow(2, t) * math.Tanh(math.Sqrt(pFactor*t))
	r.delay = math.Min(
		(next-r.prev)*rpScalingFactor*r.conf.multiplierSeconds,
		r.conf.maxWaitSeconds,
	)
	r.prev = next
	r.n++

	return true
}

// Delay returns the duration a caller should wait for before retrying.
// If it's zero, no retry should be attempted.
func (r *DecorrJitter) Delay() time.Duration {
	return time.Duration(r.delay * float64(time.Second))
}

// Reset resets the retrier so it can be reused.
func (r *DecorrJitter) Reset() {
	r.conf.random = rand.New(rand.NewSource(time.Now().UnixNano()))
	r.n = 0
	r.prev = 0
	r.delay = 0
}
